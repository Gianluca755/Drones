\documentclass[a4paper, oneside]{memoir}
\usepackage[top=25mm, bottom=25mm]{geometry}	% layout margin
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{amsfonts}


\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}} % for multilevel list

\title{Report for the Project of Distributed Systems}

\author{Ermacora Gianluca 132923\\ Rovere Andrea 128074}

\date{\today}

\begin{document}


\begin{titlingpage}
\maketitle
\begin{abstract}
The goal of this project is creation of a simulation of a network of drones that satisfy the delivery requests of packages from clients. The entities in this project are the clients, the servers that offer important functionalities, the drones and the recharging stations.
\end{abstract}
\end{titlingpage}
\tableofcontents
\chapter{Introduction}\label{ch:intro}

%In this chapter you describe the main problem, and an idea of the solution. It is not necessary to be very detailed or formal, but it is important to explain which are the main aims and issues from the point of view of Distributed Systems:
%\begin{itemize}
%A description of the application.
%The overall structure of the implementation: how resources are deployed, which are the players, the roles.
%\item The distributed system features (and the transparencies) and algorithms you intend to implement.
%\item Your plan for testing the system.
%\item A schedule for how you plan to carry our your design and implementation
%\end{itemize}

\section{Description of the application.}
The problem to solve is the delivery of packages and management of a dynamic fleet of drones.

The space is modelled by a 2D grid, so the diagonal movements of drones are calculated with some approximation. There aren't forbidden zones nor forced paths.

The drones have cellular connectivity and know a few other drones. They are equipped with GPS and we assume they have an ID, it's not a limitation since the ID could be given by the manager server (see below). The drones have all the same constant speed.

There are some recharging and repairing stations on the map. For simplicity the recharging and repairing stations are assumed to coincide and they have unlimited capacity.

There is a server that centralize the orders of the clients and act as a reliable message broker (as middle-man).

There is a server which provide some management of drones, and make sure the order is carried out. In particular, the tracker functionality, when a new drone is connected the server will provide a list of other drones to connect to. Under the idea, that there could be different types of drones that would require different recharging/repairing station, we choose to provide to every drone their list of stations. An other option would have been to encode the needed logic in the manager.

The two servers are separated due to the fact that we are following the principle of separation of concerns, and because in case of multiple fleets of drones we would have one broker and various manager servers.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{Overview}
\end{figure}

A client can send a request to the broker server for the delivery of a package from point A to point B, a drone will be selected based on the minimum distance relative to point A, its battery and maximum carry weight, the selected drone will carry out the delivery of the package.

After a drone refused three orders due to the low battery, it will go to the recharging station, this will mitigate but not prevent the refuse of a package by the fleet; the manager will handle the case by retrying.

A drone can crash at any point in time, if it was able to signal the fail, another drone will be selected to transport the broken drone to the nearest charging station, if the broken drone was satisfying a request a second drone will be selected to complete the task.

It is not required to consider security problems or Byzantine behaviour of the drones.


\section{Structure of the implementation}

The client position is not considered in our system, drones can be in any point in the map and move only if they need to deliver a package or if they need to recharge, the charging stations are located in fixed points in the map, their position is known to all drones.

The key players in our implementation are listed below.
\begin{itemize}
\item \textbf{Client}: the client sends a request to the broker server for a delivery. It's also able to query the broker asking for the status of the delivery.
\item \textbf{Drone}: the drones are the entities that move the packages between locations, new drones that want to join the network send a message to the manager server, drones with low battery must go to a charging station to recharge.
\item \textbf{Broker server}: this server receives the requests from clients, it's a single point of failure so it is replicated by a backup copy (it's possible to have more copies).
\item \textbf{Manager server}: this server handles the join of a new drone in the network, a drone can have it's own unique ID or can obtain one from this server. Other functionalities are the detection of an offline drone and consequentially offers the best-effort guarantee of successful delivery. The server is a single point of failure so it is replicated by a backup copy (it's possible to have more copies).
\item \textbf{Recharging/Repairing station}: these are stations in fixed points in the map where drones can go to recharge their battery and where broken drones can be brought for repairs.
\end{itemize}


\section{System features}
\label{System-features}

The system transparencies that we aim to implement are:
\begin{itemize}
	\item \textbf{concurrency transparency}: only one drone will be selected to carry out the delivery of a package, but multiple orders from multiple clients are handled concurrently;
	\item \textbf{failure transparency}: if a drone crashes the delivery must be completed smoothly for the client, if the broker server or the manager server crash the systems will connect to a secondary backup server;
	\item \textbf{location transparency}: the position of the drones is unknown to the clients;
	\item \textbf{performance and scaling transparency}: the system must be able to scale smoothly when adding more drones;
	\item \textbf{reconfiguration transparency}: the entrance of a new drone in the network must have a low overhead.
\end{itemize}

\subsection{Assumption}
We utilized the simplify assumption that the channels offer reliable delivery without data duplication. This isn't an unrealistic assumption since we can imagine to transfer data packets (UDP) over an overlay TCP network. While the nodes may crash at any time.

\subsection{Election Algorithm}
For the election of the drone we firstly considered the "Bracha-Toueg fail consensus algorithm", then the "Echo with extinction", then we reached the conclusion that also the "Echo" would work.
The "Bracha-Toueg" was discarded because it needs to know the size of the network (N), this means that the manager needs to calculate and distribute an approximation of the size to all drones.
The other problem was that the "Bracha-Toueg" needs a major modification which consists in making sure that the majority of the network converges to the minimum distance known by the network.

The differences between the "Echo" and "Echo with extinction" are that: in the "Echo" the algorithm has a single initiator, that makes the last decision in the election, which needs to be broadcasted; while in the "Echo with extinction" the initial node is really a propagator of the request for all the nodes start a wave, so this initial node make the broadcast of the order and when the execution terminates the elected node knows that is elected.

The message complexity for the "Echo" algorithm is $2M$ plus the propagation complexity of the decision $O(M)$ where $M$ is the number of edges in the network. So the total complexity is $ O(M) $.
Instead the message complexity for the "Echo with extinction" is $O(M)$ for the initial broadcast and then $O(N M)$ for the algorithm.

The situation is obvious: the "Echo" is the better choice in the worst case.
The drawback is that the failure of a drone during an election will block the election; this situation is mitigated by the manager that will restart the election while if a drone doesn't respond it will be removed from the list of neighbours on the drones involved.
A mitigation of this drawback is that since the manager have to handle the generic failure of a drone, it can also handle the failed election, which is a just particular case.

The "Echo" algorithm has been chosen due to the lower message complexity; that is a solid justification, because a comparison of the performance of the two algorithm over multiple election, in real cases, over a realistic network topology, is outside the scope of this project.

Simplification: under the assumption that the drones can reach each other, the communication of the decision of the election algorithm is made by a single message from the initiator node to the elected node.

Note: the criterion used for the decision of the node is based on distances instead of IDs, the IDs are used only in case of conflict due to same distance.


\section{Test cases}

To test our system we'll use a program that simulates the environment and spawns drones in random positions and with random requests from clients.

The test cases that will be analysed are listed below:\\

Normal conditions:
\begin{itemize}
	\item the case where a drone successfully completes a delivery request;
	\item the case where a drone has to go to a charging station;
	\item the case where a new drone joins the network;
\end{itemize}

Critical situations:
\begin{itemize}
	\item the case where a drone crashes while it's idle;
	\item the case where a drone crashes after it has been selected to move a package but it has not picked up the package yet;
	\item the case where a drone crashes after it has picked up the package and it's delivering it to point B;
	\item the case where a drone has low battery power;
	\item the case where a drone is out of battery power due to misreading of the sensor or strong wind;
	\item the case where a drone crashes after it has given its availability for election to the network;
	\item the case where no drone is available to deliver a package;
	\item the case where a drone crashes during the join request to the manager server.
\end{itemize}


%\section{Schedule for the design and implementation of the system}
%The schedule for how you plan to carry our your design and implementation is as follows:
%\begin{enumerate}
%\item Design of the system and definition of the functional and non-functional requirements;
%\item Selection of the programming language for the implementation;
%\item Specification of the protocols and algorithms that are used in the system;
%\item Implementation of the entities that play a role in the system and the communication between them;
%\item Testing of each part of the system and the system as a whole;
%\end{enumerate}

\chapter{Analysis}\label{ch:analysis}

%In this chapter, we describe in detail functional and non-functional requirements of a solution for the problem.

\section{Functional requirements}
\label{func-req}
%Which functions must be offered to users / other programs?  Which are the input data and the output data? Which is the expected effect?

The following are the functional requirements required by the project:
\begin{itemize}
\item \textbf{Make a delivery request}: a client can request the delivery of a package form point A to point B.

	\textbf{Input}: the package starting position, the destination and the weight of the package;

	\textbf{Output}: there is no output;

	\textbf{Effect}: the election of a drone.

\item \textbf{Request the status of a delivery}: the client can request the status of its request to the broker server.

 	\textbf{Input}: the identification number for the order;

	\textbf{Output}: a message to the client signalling the status of the delivery;

	\textbf{Effect}: letting the client know about the status of the delivery.

\item \textbf{Support for a crashed drone while it is idle}: a drone that crashes while idle can request to be taken to a repair station.

	\textbf{Input}: the broken drone position;

	\textbf{Output}: there is no output;

	\textbf{Effect}: the election of a drone that will move the broken drone to a repair station.

\item \textbf{Support for a broken drone after it has been elected}: a drone that crashes after it has been chosen can request to be taken to a repair station.

	\textbf{Input}: the broken drone position and whether or not it picked up the package;

	\textbf{Output}: there is no output;

	\textbf{Effect}: the effect is the election of a drone that will move it to a repair station and the election of another drone to carry out the delivery.

\item \textbf{A new drone joins the network}: a new drone that wants to join the network sends a message to the management server.

	\textbf{Input}: the new drone unique ID if it has one, its supported weight and its position;

	\textbf{Output}: the unique ID (if needed) and the other drones to connect to;

	\textbf{Effect}: the entrance of the new drone in the network and the update of the manager drone table and the drones neighbour lists.

\item \textbf{Election of a drone to carry out a task}: a drone will be selected based on its characteristics and its position, to carry out the task.

	\textbf{Input}: the drone table and the task to do;

	\textbf{Output}: the selected drone or an error message if one can't be selected;

	\textbf{Effect}: the selection of a specific drone to carry out a delivery or to move a broken drone to a repair station.

\end{itemize}

\section{Non-functional requirements}
\label{nfunc-req}
%Everything about mode and transparencies: availability, mobility, security, fault tolerance, etc.
%Are there execution time bounds? Minimum data rates?
%If requested, specific platforms/languages/middlewares requirements for the implementation can be decided here. (E.g.: if the project is on a SOA, we may request that functions are offered via SOAP or RESTful services).

The following are the non-functional requirements required by the project:
\begin{itemize}
\item the minimum weight of a package it's 0 grams and it can't weigh more than 1500 grams;
\item there are no restrictions on the movements of the drones through the map or their position on the map;
\item there are no restrictions on the position of the source or destination of the delivery request;
\item the system must be able to recover from the failure of a drone or a server;
%\item a drone has to respond to messages from other drones or the management servers within 10 seconds or it will be considered dead;
\item it's important that the following transparencies are present:
	\begin{itemize}
	\item \textbf{concurrency}: only one drone will be selected to carry out the delivery of the package, and multiple drones are executing the delivery and the fleet of drones is running multiple election concurrently;
	\item \textbf{reconfiguration}: the entrance of a new drone in the network must have a low overhead;
	\item \textbf{failure}: if a drone crashes the delivery must be completed smoothly for the client;
	\item \textbf{performance and scaling}: the system must be able to scale smoothly when adding more drones;
	\item \textbf{location}: the position of the drones is unknown to the clients.
	\end{itemize}
\end{itemize}


\chapter{Project}
In this chapter we'll describe the logical architecture of our system, the structure of the messages exchanged in our system, the algorithms used and we'll explain in detail the most important functions of our system.

The project has been designed thinking of using Erlang as the main programming language.
%This chapter is devoted to the description of the general architectures, and specific algorithms.

\section{Logical architecture}
%Describe the components of your systems: modules/objects/components/services. For each component, describe the functionalities it implements, and by who is used.
\subsection{Modules used in the implementation}
The Erlang modules used in the implementation of the system are:
\begin{itemize}
\item \textbf{broker.erl}: this module contains all the functions needed by the broker server to handle the delivery requests and to communicate them to the management server and to handle the query requests from the clients;
\item \textbf{client.erl}: this module contains all the functions needed by the client to make a delivery request and to query the status of its delivery;
\item \textbf{drone.erl}: this module contains all the functions needed by the drone to exchange messages with other drones for the election and with the management server to start the election and to update the status of the delivery;
\item \textbf{election.erl}: this module contains all the functions needed to elect a drone for the delivery and to exchange messages with the drones to achieve this goal;
\item \textbf{environment.erl}: the role of this module is to set up the broker and the manager servers and to spawn the clients and the drones;
\item \textbf{manager.erl}: this module contains all the functions needed by the manager server to handle the join of a new drone, to start the election procedure and to update the relative drone table and order status;
\item \textbf{utils.erl}: this module contains some functions that are useful for multiple other modules.
\end{itemize}


\subsection{Primary backup schema}
\label{Primary-backup-schema}
Since the broker and the manager servers are both single point of failure, it has been chosen to implement a backup for them. The schema used is the simplest: one primary and one backup.

After some experiments it has been chosen to handle the messages received by the servers, (broker and manager) in the following way: the backup server keeps pinging the primary. When the acting primary receives a message related to the orders of the clients it start a new Erlang process to handle the message. This new Erlang process contacts the backup server which create an other Erlang process. The two new processes synchronize the status of the order between the primary and backup server.

This approach permits an efficient use of the resources since it prevents blocking, allows to handle a vast number of messages thanks to the lightweight Erlang processes. Moreover when a fail happened it will disrupt only a small step of the execution of an order, instead of the entire server.

\section{The space of movement}
The space where the drones can move is a rectangle with length and heigh are natural numbers. The drones move at a constants speed of 1 square per second.
In the early version the movement will not be shown, the drone will change position instantly after the needed period of time has passed.
We make the simplifying assumption that the drones that aren't moving don't consume battery power.

\section{Protocols and algorithms}
%Communication between components.


\subsection{Status of an order}
The delivery order from the client can be in one of the following status:
\begin{itemize}
\item \textbf{inProgress}: an order is in this state after the order message has been reliably store by the manager;
\item \textbf{inDelivery}: an order is in this state after the information about the elected drone has been reliably store by the manager;
\item \textbf{delivered}: an order is in this state after the package has been delivered to it's destination and the manager server receives the "delivered" message form the drone.
\end{itemize}

\subsection{Status of a drone}
The drone can be in one and only one of the following states:
\begin{itemize}
	\item \textbf{idle}: this is the state when it's not delivering or recharging;
	\item \textbf{charging}: this is the state when the drone is going to a recharging station or is already there, it can start or propagate the messages of the election.
	\item \textbf{\{delivering, ClientID, OrderID, Source, Destination, Weight \}}: this is the state of the drone while it's delivering a package, it can start or propagate the messages of the election.
	\item \textbf{failedOnline}: in this state the drone can't move but can send and receive messages.
	\item \textbf{failedOffline}: in this state the drone can't move and can't send and receive messages.
\end{itemize}


\subsection{Messages: formats and effects}

From client to broker
\begin{itemize}
	\item New order: "\{makeOrder, ClientAddress, ClientID, OrderID, \{Source, Destination, Weight\}\}".
	Source and Destination are tuples referring to the starting and destination location of the package, Weight refers to the weight of the package. The broker acknowledge it with "confirmedOrder" when the order has been reliably saved.

	\item Query order: "\{queryOrder, ClientAddress, ClientID, OrderID\}".
	This message is a request for information on a particular order. The broker replies with "orderNotPresent" if there is no order with the given OrderID and ClientID or with the status of the order.
\end{itemize} \vspace{1em}
From broker to manager
\begin{itemize}
	\item New order: "\{makeOrder, ClientAddress, ClientID, OrderID, \{Source, Destination, Weight\}\}".
	This is the message received from a client, by the broker; the manager will reliably store it and it will reply with "\{inProgress, \{\}, ClientID, OrderID, \{\}\}".
\end{itemize} \vspace{1em}
From manager to broker
\begin{itemize}
	\item Update of an order: "\{Type, \{\}, ClientID, OrderID, \{\}\}".
	Where the type of the message is the status of the order, which can be \textit{inProgress, inDelivery, delivered}. The broker will reliably store the new status without replying to the manager.
\end{itemize}\vspace{1em}
From manager to drones
\begin{itemize}
	\item New order: "\{makeOrder, ClientAddress, ClientID, OrderID, \{Source, Destination, Weight\}\}".
	This is always the original message, the random drone will start the election without notify the manager.

	\item Drone status: "\{droneStatus, Address\}".
	This message is used to ask information about the status of to the drone. \textit{Address} is for messaging back.

	%\item Order status:

	\item List of drones: "\{droneList, ListOfAddresses\}".
	The message contains the list of new neighbours drones.

	\item New drone: "\{newDrone, NewDroneAddr\}".
	The message is the response at the request of new drone by a drone with a low number of neighbours.

	\item Confirm reception: "confirmDelivered".
	This is the reply to the message from the drone that notify the completion of the delivery.

\end{itemize} \vspace{1em}
From drones to manager
\begin{itemize}
	\item Registration: "\{joinRequest, DroneID, DroneAddress\}".
	The drone will send the message to the manager to express its interest in joining the network, the manager will respond with a list of drones addresses.

	\item Request new drone address: "\{ requestDroneAddr, DroneID, DroneAddr\}".
	This message is sent when the drone has a low number of neighbours. The variables contains information about the sender.

	\item Package delivered: "\{delivered, DroneAddress, ClientID, OrderID, \{\}\}".
	The drone will send the message to the manager which will reliably store it. The manager will reply with "confirmDelivered", and will notify the broker.

	\item Election result: "\{inDelivery, DroneID, ClientID, OrderID, \{\}\}".
	The elected drone for an order will inform the manager that the delivery will start.

	\item Election failure due to weight: "\{excessiveWeight, \{\}, ClientID, OrderID, \{\}\}".
	The election failed, for the current order, because there wasn't an available drone with sufficient carry capacity.

	\item Failure: "\{failureNotification, DroneAddress, DroneID, \{\}, \{\}\}".
	The drone will send the message to the manager informing it of the drone failure.
\end{itemize} \vspace{1em}
From drones to drones
\begin{itemize}
	\item Connection request: "\{connection, DroneAddress\}".
	This message is sent when a drone wants to connect to an other. The reception of this message will trigger a response (see next item).

	\item Connection confirmation: "confirmConnection".
	The message is sent after the drone that made the request has been added to the list of neighbours. This message is the response of the previous one.

	\item Query status: "\{queryOnline, DroneAddress\}".
	This message is sent by a drone that want to know if the other drone is online. The \textit{DroneAddress} is the address for the response.

	\item Response query: "online".
	This message is the response at the previous query.

	\item Echo election propagation: "\{election, HandlerAddress, ClientID, OrderID, \{Source, Destination, Weight\}\}".
	This message is sent in the first phase of the election.

	\item Echo election back-propagation: "\{result, ElectedDroneID, ElectedPid, Distance, \{ClientID, OrderID\}\}".
	This message is sent in the second phase of the election to the designed parent.

	\item Echo election notification: "\{elected, ClientID, OrderID, Source, Destination, Weight\}".
	This message is sent from the initiator to the elected node to inform it of the result.
\end{itemize}
\newpage


%UML sequence diagrams go here.
\textbf{Join of a new drone}

The Join of a new drone in the network follows the following steps:
\begin{enumerate}
\item The drone that wants to join the network sends a message to the management server indicating its drone ID and its maximum carry weight;
\item the management server saves the characteristics of the drone and responds with a list of drones;
\item the drone sends a connect message to each drone in the list given by the management server;
\item every drone contacted responds with an ack message,
\item every time the new drone receives an ack message it will add that drone to its neighbour list.
\end{enumerate}

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{New-drone}
	\caption{UML diagram for the join of a new node }
\end{figure}


\textbf{New delivery request}

The execution of a new delivery request follows the following steps:
\begin{enumerate}
\item The client sends a message to the broker server with the delivery request;
\item the broker server saves the order, then it sends back an ack message to the client, finally it delivers the request to the manager server;
\item once the manager server receives the request, it stores the order then replies to the broker server with the message "inProgress" which is equivalent to an ack, then it selects a random drone and delivers the request to it;
\item the chosen drone initiates the election procedure and exchanges the necessary messages with other drones;
\item once a drone has been selected to carry out the delivery it sends a message to the manager server informing it of the result of the election;
\item the manager server notifies the broker server of the new status of the delivery;
\item the selected drone carries out the delivery and once it deposits the package at the destination it sends a message to the manager server updating the status of the delivery;
\item the manager server saves the new status of the delivery, responds with an ack to the drone and sends a message to the broker server updating the status of the delivery;
\item at any point the client can send a message to the broker server with a query for the status of its delivery;
\item the broker server responds with a message containing the status of the request.
\end{enumerate}

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{New-order}
	\caption{UML diagram for the execution of a delivery request}
\end{figure}

\subsection{Election behaviour}
In case of successful election the initiator will notify the elected drone, in the normal case the elected drone will notify the manager.
The elected drone could fail before receiving the message or silently discarding it because is already delivering a package. The manager will later inquire the situation.
\\\\
The election could fail due to multiple reasons:
\begin{enumerate}
	\item no drones available: conclude the election without notify the manager, the manager will later retry with a new election;
	\item no drones available with sufficient battery capacity: conclude the election, the manager will later retry with a new election, after 3 times a drone can't partecipate due to battery capacity, the drone will go to a recharging station;
	\item no drone available with sufficient weight capacity: conclude the election and notify the manager;
\end{enumerate}

%Also, put here a detailed description of distributed algorithms used to solve specific problems of the project.

\section{Physical architecture and deployment}
%Which nodes and platforms involved, and where each component is deployed.
There are no specific requirements for the physical architecture, the drones can be deployed in any point of the map and the clients can request deliveries form and to any point in the map, the introduction of the broker and management servers for the network and order management enables the drones to be used only for the delivery of packages.


\section{Development plan}
\label{Development-plan}
The basic (tier 1) functionalities that the system must offer are:
\begin{itemize}
\item support for a dynamic number of clients and each one can make multiple delivery requests and query the broker for the status of the order;
\item broker and manager handle the orders and have a replica backup;
\item the fleet is made of a dynamic number of drones, they may fail, the drones role is to carry the packages.
\end{itemize}

The extended (tier 2) functionalities are:
\begin{itemize}
\item basic support for takeover and failback of the servers;
\item instead of executing the various parts of the system on the same Erlang Machine, use containers to separate the various components of the system;
\item transportation of a broken drone (with various possible weights), to a repairing station;
\item support for drone unable to reach a recharging station due to strong wind or faulty battery sensor;
\item ability of the manager, to launch a query to the drones, asking for info on a particular order.
\end{itemize}

%Since it is difficult to predict just how hard implementing a new system will be, you should formulate as a set of ``tiers,'' where the basic tier is something youâ€™re sure you can complete, and the additional tiers add more features, at both the application and the system level.

\chapter{Implementation}

%Details about the implementation: every choice about platforms, languages, software/hardware, middleware, which has not been decided in the requirements.
%Important choices about implementation should be described here; e.g., peculiar data structures.
\section{General aspects}
As stated before the used language is Erlang. A mention is due to the general schema used to create finite state machine (FSM) with concurrent auxiliary processes.
In more details: there is a main loop process for modelling the FSM, this process spawns various auxiliary processes like timers or communicators which can, depending on the function, signal the final result at the main process or modifying a shared data structure of the main process.

For example, when a client ask the broker the status of an order, the broker will spawn an auxiliary process that will find the information and send it to the client.
An other example is that a server needs to replicate the data to the backup, so the primary server will spawn an auxiliary process that will contact the backup which will also spawn a process, the two auxiliary processes will communicate and update the data without blocking the main processes.

This choice has been made to improve performance and simplify the code since modelling an interaction between components is easier to do using a sequential procedure with blocking calls.


\section{Data storage for servers}
Currently the replication of the server function only as a backup there is no automatic takeover nor failback.

The storage of data relative to orders in the broker server and, drones and order in the manager server is done through the "Erlang Term Storage" (ETS) for the development mode with the purpose of preventing SSD consumption. In production the function calls should be substituted with the "Disk Erlang Term Storage" (DETS), an other option which require small changes is to use the Mnesia: the database included in Erlang, or some other database. In the development mode we choose the AVL tree as the data structure used by ETS over the hash table, without particular justification.

\chapter{Validation}
%Check if requirements from Chapter~\ref{ch:analysis} have been fulfilled.
%Quantitative tests (simulations) and screenshots of the interfaces are put here.

The system is according to the transparencies declared in the section \ref{System-features}
\begin{itemize}
	\item \textbf{concurrency transparency}: the system must be able to handle multiple requests at the same time, this is done in such a way that every clients acts like if they were the only one making requests;
	\item \textbf{failure transparency}:the system manages faults of the drones and the servers in a transparent way: the broker and manager servers are synchronized with a backup server each that pings them and when the main server crashes the backup one will take its place, this way only a small part of the system will be disrupted, if a drone crashes another one will be selected to finish the delivery, it also removes the crashed drones from the drone table so they will not be candidates in other elections;
	\item \textbf{location transparency}: the client only needs to be able to connect with the broker server to request the delivery and to query the status of the request, it does not need to know which drones handle the request, their position or address or the physical position of the servers;
	\item \textbf{performance and scaling transparency}: the increase in the overall load on the network can be managed by increasing the number of drones in the network, the overhead of adding a new drone to the network is negligible. There is only one broker and one management server for the network and they can become bottlenecks, this could be solved by adding in the a proxy server that chooses the leader of the various broker servers;
	\item \textbf{reconfiguration transparency}: the structure of the network is not significantly impacted by the addition of a new drone, when a node crashes the network reconfigures itself in a transparent way for the client by removing the crashed drone from the drone table of the manager and the neighbour list of the other drones.
\end{itemize}

\section{Validation of the requirements}

\subsection{Functional requirements}
The system that we have developed has been tested against the functional requirements defined in section \ref{func-req}.
The tests are in the folder \textsf{Tests} with one file for every top level entry of the list below. This tests obviously require the compilation of other parts the system.

\begin{enumerate}
\item \textbf{Request the status of a delivery}:
	\begin{enumerate}
	\item \textsf{test1:startNoOrder()} :: the client request the broker the state of a non existing delivery;
	\item the other cases are tested below.
	\end{enumerate}

\item \textbf{A new drone joins the network}:
	\begin{enumerate}
	\item \textsf{test2:startDrones()} :: the test consists in 3 drones that attempt to join the network. The behaviour is quite variable due to interleaving since the first drone will have no neighbours and it will make an other attempt to connect after some time. In other cases a drone needs to prevent a self connection and the duplicates, this is complicated by the fact that a drone may crash while an other drone makes a connection attempt.
	\end{enumerate}

\item \textbf{Make a delivery request} (without testing the election part):
	\begin{enumerate}
	\item \textsf{test3:startNoDrones()} :: when there are no drones, the client makes an order and wait for confirmation, after a certain time it will also ask the broker for the status of the order;
	\item \textsf{test3:startDrones()} :: when there are online drones, the client makes an order and wait for confirmation, after a certain time it will also ask the broker for the status of the order.
	\end{enumerate}

\item \textbf{A drone with low battery goes to the recharging station}:
	\begin{enumerate}
	\item \textsf{test4:startRecharge()} :: in this case the drone is forced to go the recharging station.
	\end{enumerate}

\item \textbf{Election of a drone to carry out a task}:
	\begin{enumerate}
	\item \textsf{test5:startElection()} :: in this case there are only 3 drones without servers, a single request will be created and a drone will be elected.
	\end{enumerate}

\item \textbf{Client make a delivery request which is carried out}
	\begin{enumerate}
	\item \textsf{test6:startOrder()} :: this is the compete test for the basic case.
	\end{enumerate}

\item \textbf{Support for a crashed drone}:
	\begin{enumerate}
		\item the case where a drone crashes during the join request to the manager server. In this case the is no problem since the interaction doesn't require keeping a state, so the drone can retry at any time;
	\end{enumerate}

\end{enumerate}


\subsection{Non-functional requirements}
The system that we have developed partially satisfies the functional requirements defined in section \ref{nfunc-req}.

\begin{itemize}
\item[\checkmark] the minimum weight of a package it's 0 grams and it can't weigh more than 1500 grams;
\item[\checkmark] there are no restrictions on the movements of the drones through the map or their position on the map;
\item[\checkmark] there are no restrictions on the position of the source or destination of the delivery request;
\item[$\times$] the system must be able to recover from the failure of a drone or a server (the system is able to handle the failure of drones but the case of failure of a server is not completely implemented);

\item the transparencies that the system should offer are:
	\begin{itemize}
	\item[\checkmark] \textbf{concurrency}: only one drone will be selected to carry out the delivery of the package, and multiple drones are executing the delivery and the fleet of drones is running multiple election concurrently;
	\item[\checkmark] \textbf{reconfiguration}: the entrance of a new drone in the network must have a low overhead;
	\item[$\times$] \textbf{failure}: if a drone crashes the delivery must be completed smoothly for the client;
	\item[\checkmark] \textbf{performance and scaling}: the system must be able to scale smoothly when adding more drones;
	\item[\checkmark] \textbf{location}: the position of the drones is unknown to the clients.
	\end{itemize}
\end{itemize}

\section{Incomplete functionalities}

The functionalities for handling the following situations are not complete:
\begin{itemize}
	\item if a drone is out of battery power due to misreading of the sensor or strong wind;
	\item if a drone crashes while it is in idle, the neighbour drones will notice the situation at the next election and consider the drone offline;
	\item if a drone crashes after it has picked up the package;
	\item if a drone crashes after it has been selected to move a package but it has not picked up the package yet.
\end{itemize}


\chapter{Conclusions}
%All the requirements defined in the previous chapters have been met and all the basic functionalities(tier 1) defined in the development plan mentioned in section \ref{Development-plan} have been implemented, as for the extra features(tier 2) defined in the development plan:
%\begin{itemize}
%\item we have developed a schema for the switch to the backup servers as explained in section \ref{Primary-backup-schema};(to expand)
%\item the many entities of our system initially were all on the same Erlang machine but we have divided each one of them in an container to better simulate the distributed architecture of the system; (to expand)
%\item the broken drone can send a message to he management server and it will elect another drone to move the broken one to a repairing station, in our system the broken drone stays in the repair station but the system can be expanded and after a certain amount of time the drone can be considered repaired and can request to join the network again.
%\end{itemize}
The partial implementation of the backup system required various attempt and it consumed more time than estimated. As consequence the implemented system offers only a limited set of functionalities.

The basic functionalities have been tested however the whole system testing is insufficient, complex situation, unthought of, may arise.

\section{System extensions}
The possible extensions to our system are:
\begin{itemize}
	\item Broker support for multiple manager servers for various fleets of drones.
	\item Support for warehouses where the drones can stay and "rest".
	\item Separation of recharging station from the repairing station.
	\item Security concerns should be addressed, in all the parts of the system.
	\item The backup system could be improved with more servers, this can be achieved not by adding the backup server's addresses in the clients, but by a proxy server that choose the leader of the various broker servers. The broker servers can be configured with a master slave configuration or some more efficient solution like data partitioning. The proxy server can act as load balancer, accordingly to the configuration chosen.
	\item If the manager has information about the supported weight of the drones, it can avoid send false alert to an operator, when the delivery fails due to occupied drones.
	\item The selection of a drone to carry out the delivery, done by election, is certainly not weighting on the manager but allows only for simple scheduling strategies; the case where the manager act as a controller of drones should be explored due to the efficient scheduling strategies that could be implemented for the deliveries. Moreover a controller manager would be able to determine how many and which type of drones should be flying in a particular moment.
\end{itemize}



%\appendix
%
%\chapter{Appendix}
%
%In the Appendix you can put code snippets, snapshots, installation instructions, etc.
%
%
%\chapter*{Evaluation}
%Your system will be judged mainly on how it operates as a distributed system. The primary evaluation will be according to whether your system has the following attributes:
%\begin{itemize}
%\item  It should be an interesting distributed system, making use of some of the algorithms we have covered in class for distributed synchronization, replication, fault tolerance and recovery, security, etc.
%\item The software should be well designed and well implemented, in terms of the overall architecture and the detailed realization.
%\item You should devise and apply systematic testing procedures, at both the unit and systems levels.
%\item The system should operate reliably and with good performance, even in the face of failures.
%\end{itemize}
%Important, but secondary considerations include:
%\begin{itemize}
%\item Time taken to do the project (the sooner the better, but do not miss details in order to end sooner)
%\item  How nice is the application's appearance: does it have a nice interface or a compelling visual display?
%\end{itemize}

\end{document}