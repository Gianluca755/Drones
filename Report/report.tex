\documentclass[a4paper, oneside]{memoir}
\usepackage[top=25mm, bottom=25mm]{geometry}	% layout margin
\usepackage{graphicx}
\graphicspath{ {./images/} }

\title{Report for the Project of Distributed Systems}

\author{Ermacora Gianluca 132923\\ Rovere Andrea 128074}

\date{\today}

\begin{document}


\begin{titlingpage}
\maketitle
\begin{abstract}
Add something
\end{abstract}
\end{titlingpage}

\chapter{Introduction}\label{ch:intro}

%In this chapter you describe the main problem, and an idea of the solution. It is not necessary to be very detailed or formal, but it is important to explain which are the main aims and issues from the point of view of Distributed Systems:
%\begin{itemize}
%A description of the application.
%The overall structure of the implementation: how resources are deployed, which are the players, the roles.
%\item The distributed system features (and the transparencies) and algorithms you intend to implement.
%\item Your plan for testing the system.
%\item A schedule for how you plan to carry our your design and implementation
%\end{itemize}

\section{Description of the application.}
The problem to solve is the delivery of packages and management of a dynamic fleet of drones.

The space is modelled by a 2D grid, so the diagonal movements of drones are calculated with some approximation. There aren't forbidden zones nor forced paths.

The drones have cellular connectivity and know a few other drones. They are equipped with GPS and we assume they have an ID, it's not a limitation since the ID could be given by the manager server (see below).

There are some recharging and repairing stations on the map. For simplicity the recharging stations and warehouses are assumed to have unlimited capacity.

There is a server that centralize the orders of the clients and act as a reliable message broker (as middle-man).

There is a server which provide some management of drones, and make sure the order is carried out. In particular, the tracker functionality, when a new drone is connected the server will provide a list of other drones to connect to and the locations of recharging/repairing stations.

The two servers are separated due to the fact that we are following the principle of separation of concerns, and because in case of multiple fleets of drones we would have one broker and various manager servers.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{Overview}
\end{figure}

A client can send a request to the broker server for the delivery of a package from point A to point B, a drone will be selected based on its position relative to point A, its  battery and maximum carry weight, the selected drone will carry out the delivery of the package.

If a drone has low battery it will enter reserve mode, it will locate the nearest charging station and it will move in that direction, the charging stations are fixed and their location is known to all drones. After a drone refused three orders due to the low battery, it will go to the recharging station, this will mitigate but not prevent the refuse of a package by the fleet; the manager will handle the case.

A drone can crash at any point in time, if it was able to signal the fail, another drone will be selected to transport the broken drone to the nearest charging station, if the broken drone was satisfying a request a second drone will be selected to complete the task.


\section{Structure of the implementation}

The client position is not considered in our system, drones can be in any point in the map and move only if they need to deliver a package or if they need to recharge, the charging stations are located in fixed points in the map, their position is known to all drones.

The key players in our implementation are:
\begin{itemize}
\item \textbf{Client}: the client sends a request to the broker server for a delivery. It's also able to query the broker asking for the status of the delivery;
\item \textbf{Drone}: the drones are the entities that move the packages between locations, new drones that want to join the network send a message to the manager server, drones with low battery must go to a charging station to recharge;
\item \textbf{Broker server}: this server receives the requests from clients, it's a single point of failure so it is replicated by a backup copy (it's possible to have more copies);
\item \textbf{Manager server}: this server handles the join of a new drone in the network, a drone can have it's own unique id or can obtain one from this server. Other functionalities are the detection of an offline drone and consequentially offers the best-effort guarantee of successful delivery. The server is a single point of failure so it is replicated by a backup copy (it's possible to have more copies);
\item \textbf{Recharging/Repairing station}: these are stations in fixed points in the map where drones can go to recharge their battery and where broken drones can be brought for repairs.
\end{itemize}


\section{System features and algorithms}


The system transparencies that we aim to implement are:
\begin{itemize}
	\item \textbf{concurrency transparency}: only one drone will be selected to carry out the delivery of a package, but multiple orders from multiple clients are handled concurrently;
	\item \textbf{failure transparency}: if a drone crashes the delivery must be completed smoothly for the client, if the broker server or the manager server crash the systems will connect to a secondary backup server;
	\item \textbf{location transparency}: the position of the drones is unknown to the clients;
	\item \textbf{performance and scaling transparency}: the system must be able to scale smoothly when adding more drones;
	\item \textbf{reconfiguration transparency}: the entrance of a new drone in the network must have a low overhead.
\end{itemize}

\subsection{Assumption}
We utilized the simplify assumption that the channels offer reliable delivery without data duplication. This isn't an unrealistic assumption since we can imagine to transfer data packets (UDP) over an overlay TCP network.

\subsection{Election Algorithm}
For the election of the drone we firstly considered the "Bracha-Toueg fail consensus algorithm", then the "Echo with extinction", then we reached the conclusion that also the "Echo" would work. The "Bracha-Toueg" was discarded because it needs to know the size of the network (N), this means that the manager needs to calculate and distribute the size. The other problem was that the "Bracha-Toueg" needs a major modification which consists in making sure that the majority of the network converges to the minimum distance known by the network.

The differences between the "Echo" and "Echo with extinction" are that: in the "Echo" the algorithm has a single initiator, that makes the last decision in the election, which needs to be broadcasted; while in the "Echo with extinction" the initial node is really a propagator of the request for all the nodes start a wave, so this initial node make the broadcast of the order and when the execution terminates the elected node knows that is elected.

The message complexity for the "Echo" algorithm is $2M$ plus the propagation complexity of the decision $O(M)$ where $M$ is the number of edges in the network. So the total complexity is $ O(M) $.
Instead the message complexity for the "Echo with extinction" is $O(M)$ for the initial broadcast and then $O(N M)$ for the algorithm.

The decision is obvious: the "Echo" is the better choice in the worst case. The drawback is that the failure of a drone during an election will block the election; this situation is mitigated by the manager that will restart the election while if a drone doesn't respond it will be removed from the list of neighbours on the drones involved. The "Echo" has been chosen because the manager have to handle the generic failure of a drone, and the failed election is a just particular case.

The "Echo" algorithm has been chosen due to the lower message complexity, that's because a comparison of the performance of the two algorithm over multiple election, in real cases, over a realistic network topology, is outside the scope of this project.

Note: the criterion used for the decision of the node is based on distances instead of IDs, the IDs are used only in case of conflict due to same distance.


\section{Test cases}

To test our system we'll use a program that simulates the environment and spawns clients in random positions and with random requests, each entity in our system will run on a different virtual machine to better simulate the distributed aspects of our system.

The test cases that have been analysed are listed below:\\

Normal conditions:
\begin{itemize}
	\item the case where a drone successfully completes a delivery request;
	\item the case where a drone has to go to a charging station;
	\item the case where a new drone joins the network;
\end{itemize}

Critical situations:
\begin{itemize}
	\item the case where a drone crashes while it's idle;
	\item the case where a drone crashes after it has been selected to move a package but it has not picked up the package yet;
	\item the case where a drone crashes after it has picked up the package and it's delivering it to point B;
	\item the case where a drone has low battery power;
	\item the case where a drone is out of battery power due to misreading of the sensor or strong wind;
	\item the case where a drone crashes after it has sent its features(battery, position and carry weight) to the network for election;
	\item the case where no drone is available to deliver a package;
	\item the case where a drone crashes during the join request to the manager server.
\end{itemize}


\section{Schedule for the design and implementation of the system}
The schedule for how you plan to carry our your design and implementation is as follows:
\begin{enumerate}
\item Design of the system and definition of the functional and non-functional requirements;
\item Selection of the programming language for the implementation;
\item Specification of the protocols and algorithms that are used in the system;
\item Implementation of the entities that play a role in the system and the communication between them;
\item Testing of each part of the system and the system as a whole;
\end{enumerate}

\chapter{Analysis}\label{ch:analysis}

%In this chapter, we describe in detail functional and non-functional requirements of a solution for the problem.

\section{Functional requirements}

%Which functions must be offered to users / other programs?  Which are the input data and the output data? Which is the expected effect?

The following are the functional requirements required by the project:
\begin{itemize}
\item \textbf{request for a delivery}: a client can request the delivery of a package form point A to point B.

	\textbf{Input}: the package starting position, the destination and the weight of the package;

	\textbf{Output}: there is no output;

	\textbf{Effect}: the election of a drone.

\item \textbf{request for the status of a delivery}:the client can request the status of it's request to the broker server.

 	\textbf{Input}: the identification number for the order;

	\textbf{Output}: a message to the client signalling the status of the delivery;

	\textbf{Effect}: letting the client know about the status of the delivery.

%\item \textbf{election of a drone for the delivery}: the network of drones elects the most suitable drone to carry out the delivery, the input is the position, carry weight and battery of each drone, there is no output, the effect is to elect the drone that will make the delivery;
\item \textbf{message after crash while idle}: a drone that crashes while idle can request to be taken to a repair station,

	\textbf{Input}: the broken drone position;

	\textbf{Output}: there is no output;

	\textbf{Effect}: the election of a drone that will move the broken drone to a repair station.

\item \textbf{message after crash after being chosen}: a drone that crashes after it has been chosen can request to be taken to a repair station.

	\textbf{Input}: the broken drone position and whether or not it picked up the package;

	\textbf{Output}: there is no output;

	\textbf{Effect}: the effect is the election of a drone that will move it to a repair station and the election of another drone to carry out the delivery.

\item \textbf{a new drones to joins the network}:a new drone that wants to join the network sends a message to the management server.

	\textbf{Input}: the new drone unique id if he has one, its carry weight and it's position;

	\textbf{Output}: the unique id(if needed) and the other drones to connect to;

	\textbf{Effect}: the entrance of the new drone in the network.

\end{itemize}

\section{Non functional requirements}

%Everything about mode and transparencies: availability, mobility, security, fault tolerance, etc.
%Are there execution time bounds? Minimum data rates?
%If requested, specific platforms/languages/middlewares requirements for the implementation can be decided here. (E.g.: if the project is on a SOA, we may request that functions are offered via SOAP or RESTful services).

The following are the non-functional requirements required by the project:
\begin{itemize}
\item there is no limit on the minimum weight but the package can't weigh more than X;
\item it's important for following transparencies to be present:
	\begin{itemize}
	\item \textbf{concurrency}: only one drone will be selected to carry out the delivery of the package;
	\item \textbf{reconfiguration}: the entrance of a new drone in the network must have a low overhead;
	\item \textbf{failure}: if a drone crashes the delivery must be completed smoothly for the client;
	\item \textbf{performance and scaling}: the system must be able to scale smoothly when adding more drones;
	\item \textbf{location}: the position of the drones is unknown to the clients.
	\end{itemize}
\end{itemize}


\chapter{Project}

This chapter is devoted to the description of the general architectures, and specific algorithms.

\section{Logical architecture}
Describe the components of your systems: modules/objects/components/services.
For each component, describe the functionalities it implements, and by who is used.

\subsection{Primary backup schema}
Since the broker and the manager servers are both single point of failure, it has been chosen to implement a backup for them. The schema used is the simplest: one primary and one backup.

After some experiments it has been chosen to handle the messages received by the servers, (broker and manager) in the following way: the loop process exchange pings with its backup and when receives a message related to the orders of the clients it start a new Erlang process to handle the message. This new Erlang process contacts the backup server which create an other Erlang process. The two new processes synchronize the status of the order between the primary and backup server.

This approach permits an efficient use of the resources since it prevents blocking, allows to handle a vast number of messages thanks to the lightweight Erlang processes. Moreover when a fail happened it will disrupt only a small step of the execution of an order, instead of the entire server.


\section{Protocols and algorithms}
Communication between components.

\subsection{Status of the order}
The delivery order from the client can be in one of the following status:
\begin{itemize}
\item \textbf{inProgress}: an order is in this state after the order message has been reliably store by the manager;
\item \textbf{inDelivery}: an order is in this state after the information about the elected drone has been reliably store by the manager;
\item \textbf{delivered}: an order is in this state after the package has been delivered to it's destination and the manager server receives the "delivered" message form the drone.
\end{itemize}


\newpage
\subsection{Messages: formats and effects}

From client to broker
\begin{itemize}
	\item New order: "\{makeOrder, ClientAddress, ClientID, OrderID, \{Source, Destination, Weight\}\}"
	Source and Destination are tuples {X, Y} referring to the starting location and the destination location of the package, Weight refers to the weight of the package. The broker acknowledge it with "confirmedOrder" when the order has been reliably saved.

	\item Query order: "\{queryOrder, ClientAddress, ClientID, OrderID\}". The broker replies with "orderNotPresent" if there is no order with the given OrderID and ClientID or with the status of the order.
\end{itemize} \vspace{1em}
From broker to manager
\begin{itemize}
	\item New order: "\{makeOrder, ClientAddress, ClientID, OrderID, \{Source, Destination, Weight\}\}"
	This is the message received from a client, by the broker; the manager will reliably store it and it will reply with "\{inProgress, \{\}, ClientID, OrderID, \{\}\}".
\end{itemize} \vspace{1em}
From manager to broker
\begin{itemize}
	\item Update of an order: "\{Type, \{\}, ClientID, OrderID, \{\} \}"
	Where the type of the message is the status of the order, which can be inProgress, inDelivery, delivered. The broker will reliably store the new status without replying to the manager.
\end{itemize}\vspace{1em}
From manager to drones
\begin{itemize}
	\item New order: "\{makeOrder, ClientAddress, ClientID, OrderID, \{Source, Destination, Weight\}\}"
	This is always the original message, the random drone will start the election without notify the manager.

	\item Drone status:

	\item Order status:
\end{itemize} \vspace{1em}
From drones to manager
\begin{itemize}
	\item Election result: "\{inDelivery, DroneAddress, ClientID, OrderID, \{\} \}"

	\item Package delivered: "\{delivered, DroneAddress, ClientID, OrderID, \{\} \}"
	The drone will send the message to the manager which will reliably store it. The manager will reply with "confirmDelivered", and will notify the broker.

	\item Registration:  "\{joinRequest, DroneAddress, DroneID, \{MaxCarry\}, \{\} \}"
	The drone will send the message to the manager to express it's interest in joining the network, the manager will respond with a list of drones for it to connect to.

	\item Failure:  "\{failureNotification, DroneAddress, DroneID, \{\} \}, \{\} \}"
	The drone will send the message to the manager informing it of the drone failure.
\end{itemize} \vspace{1em}
From drones to drones
\begin{itemize}
	\item Echo election: "\{election, HandlerAddress, ClientID, OrderID, \{Source, Destination, Weight\}\}"
\end{itemize}
\newpage


UML sequence diagrams go here.
\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{New-drone}
	\caption{UML diagram for the join of a new node }
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{New-order}
	\caption{UML diagram for the execution of a delivery request}
\end{figure}

Also, put here a detailed description of distributed algorithms used to solve specific problems of the project.

\section{Physical architecture and deployment}
Which nodes and platforms involved, and where each component is deployed.

\section{Development plan}
The base functionalities that the system must offer are:
\begin{itemize}
\item a client can make a delivery request;
\item communication between the drones an with the management server for the drone election;
\item selection of a new drone to complete a delivery if the current one crashes;
\item addition of more drones.
\end{itemize}
The optional functionalities are:
\begin{itemize}
\item consider the weight of the package in the selection of the drone;
\item a method for the client to request the status of the delivery;
\end{itemize}

%Since it is difficult to predict just how hard implementing a new system will be, you should formulate as a set of ``tiers,'' where the basic tier is something youâ€™re sure you can complete, and the additional tiers add more features, at both the application and the system level.

\chapter{Implementation}

Details about the implementation: every choice about platforms, languages, software/hardware, middlewares, which has not been decided in the requirements.


Important choices about implementation should be described here; e.g., peculiar data structures.

The storage of data relative to orders in the broker server and, drones and order in the manager server is done through the "Erlang Term Storage" (ETS) for the development mode with the purpose of preventing SSD consumption. In production the function calls should be substituted with the "Disk Erlang Term Storage" (DETS), an other option which require small changes is to use the Mnesia: the database included in Erlang, or some other database. In the development mode we choose the AVL tree as the data structure used by ETS over the hash table, without particular justification.

\chapter{Validation}

Check if requirements from Chapter~\ref{ch:analysis} have been fulfilled.
Quantitative tests (simulations) and screenshots of the interfaces are put here.


\chapter{Conclusions}

The possible extensions are:
\begin{itemize}
	\item realistic broker for large numbers of clients on multiple locations.
	\item Broker support for multiple manager servers for various fleets of drones.
	\item Support for warehouses, dynamic number of drones.
	\item Security concerns should be addressed, in all the parts of the system.
	\item The backup system could be improved with more servers, this can be achieved not by adding the backup server's addresses in the clients, but by a proxy server that choose the leader of the various broker servers. The broker servers can be configured with a master slave configuration or some more efficient solution like data partitioning. The proxy server can act as load balancer, accordingly to the configuration chosen.
\end{itemize}

Limit: scheduling performance.
\appendix

\chapter{Appendix}

In the Appendix you can put code snippets, snapshots, installation instructions, etc.


\chapter*{Evaluation}
Your system will be judged mainly on how it operates as a distributed system. The primary evaluation will be according to whether your system has the following attributes:
\begin{itemize}
\item  It should be an interesting distributed system, making use of some of the algorithms we have covered in class for distributed synchronization, replication, fault tolerance and recovery, security, etc.
\item The software should be well designed and well implemented, in terms of the overall architecture and the detailed realization.
\item You should devise and apply systematic testing procedures, at both the unit and systems levels.
\item The system should operate reliably and with good performance, even in the face of failures.
\end{itemize}
Important, but secondary considerations include:
\begin{itemize}
\item Time taken to do the project (the sooner the better, but do not miss details in order to end sooner)
\item  How nice is the application's appearance: does it have a nice interface or a compelling visual display?
\end{itemize}

\end{document}